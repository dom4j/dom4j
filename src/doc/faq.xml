<?xml version="1.0" encoding="ISO-8859-1"?>
<document url="http://www.dom4j.org/faq.xml">
  <body>
    <title>Frequently Asked Questions</title>
    
    <section title="What is DOM4J?">
      <p><b>DOM4J</b> is an Open Source XML framework for Java.
      <b>DOM4J</b> allows you to read, write, navigate, create and modify 
      XML documents. 
      <b>DOM4J</b> integrates with DOM and SAX and is seamlessly integrated 
      with full XPath support.
      </p>
    </section>

    <section title="What is the DOM4J license?">
      <p>We use an Apache-style open source license which is one of the least
        restrictive licenses around, you can use DOM4J to create new products
        without them having to be open source.
      </p>
    </section>

    <section title="What do I need to add to my CLASSPATH?">
      <p>The dom4j-all.jar contains everything you need to use DOM4J so that is 
        the only JAR you'll need to add to your CLASSPATH.
        No other JAR is necessary! DOM4J comes complete with a default 
        SAX parser so its ready to run straight out of the box.</p>

      <p>DOM4J can use your existing XML parser and/or DOM implementation 
        (such as <a href="http://xml.apache.org/crimson/">Crimson</a> or 
        <a href="http://xml.apache.org/xerces-j/">Xerces</a> if you want it to. DOM4J can also use
        <a href="http://java.sun.com/xml/">JAXP</a> to configure which SAX Parser to use - just add the 
        jaxp.jar to your CLASSPATH and whichever SAX parser you wish away you go.
      </p>
    </section>

    <section title="How does DOM4J relate to DOM?">
      <p>DOM is a quite large language independent API.
        DOM4J is a simpler, lightweight API which is optimised for the Java 
        making extensive use of the Java 2 platform such as the 
        Java 2 collections.
      </p>
      <p>Though DOM4J fully supports the DOM standard allowing both APIs to be 
        used easily together.
      </p>
    </section>

    <section title="How does DOM4J relate to JDOM?">
      <p>DOM4J is a different project and different API to JDOM
        though they both have similar goals. They both attempt to make it easier
        to use XML on the Java platform. 
        They differ in their design, API and implementation.
      </p>
      <p>DOM4J is based on Java interfaces so that plug and play 
        document object model implementations are allowed and encouraged
        such as small, read only, quick to create implementations or 
        bigger, highly indexed fast to naviagte implementations or 
        implementations which read themselves lazily from a database or 
        Java Beans etc.
      </p>
      <p>DOM4J uses polymorphism extensively such that all document object types 
        implement the Node interface. 
        Also both the Element and Document interfaces can be used polymorphically
        as they both extend the Branch interface.
      </p>

      <p>DOM4J is fully integrated with XPath support throughout the API 
        so doing XPath expressions is as easy as
      </p>
<pre>
SAXReader reader = new SAXReader();
Document document = reader.read( url );
List links = document.selectNodes( "//a[@href]" );
String title = document.valueOf( "/head/title" );
</pre>
      <p>DOM4J will soon provide a configuration option to
        support the W3C DOM API natively to avoid unnecessary tree duplication
        when using DOM4J with XSLT engines etc.
      </p>
    </section>

    <section title="How does DOM4J work with DOM and SAX?">
      <p>You can create DOM4J documents from XML text, SAX events or existing 
        DOM trees or you can write DOM4J documents as SAX events, DOM trees 
        or XML text.
      </p>
    </section>

    <section title="How can I use XSLT with DOM4J?">
      <p>DOM4J integrates with XSLT using the JAXP standard (TRaX) APIs.
        A DOM4J Document can be used as the source of XML to be styled or 
        the source of the stylesheet. 
        A DOM4J Document can also be used as the result of a transformation. 
      </p>
      <p>First you'll need to use JAXP to load a Transformer.
      </p>
<pre>
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamSource;
import org.dom4j.Document;
import org.dom4j.DocumentResult;
import org.dom4j.DocumentSource;
...

TransformerFactory factory 
  = TransformerFactory.newInstance();

Transformer transformer 
  = factory.newTransformer( new StreamSource( "foo.xsl" ) );
</pre>
      <p>Now that you have a transformer its easy to style a Document into 
      a new Document.
      </p>
<pre>
DocumentSource source = new DocumentSource( document );
DocumentResult result = new DocumentResult();
transformer.transform( source, result );

Document transformedDoc = result.getDocument();
</pre>
      <p>If you want to transform a Document into XML text you can use JAXP as follows:-
      </p>
<pre>
DocumentSource source = new DocumentSource( document );
DocumentResult result = new StreamResult( new FileReader( "output.xml" ) );
transformer.transform( source, result );
</pre>
      <p>For more information on JAXP and (TRaX) try 
        <a href="http://java.sun.com/xml/">Sun's JAXP site</a>.
      </p>
    </section>


    
    <section title="How does DOM4J handle very large XML documents?">
      <p>DOM4J provides an event based model for processing XML documents.
        Using this event based model allows developers to prune the XML tree
        when parts of the document have been successfully processed avoiding
        having to keep the entire document in memory.
      </p>
      <p>For example, imagine you need to process a very large XML file that is 
        generated externally by some database process and looks something like 
        the following (where N is a very large number).
      </p>
      <pre>
<![CDATA[<ROWSET>
    <ROW id="1">
        ...
    </ROW>
    <ROW id="2">
        ...
    </ROW>
    ...
    <ROW id="N">
        ...
    </ROW>
</ROWSET>]]>     
      </pre>
      <p>We can process each &lt;ROW&gt; at a time, there is no 
        need to keep all of them in memory at once. 
        DOM4J provides a <i>Pruning Mode</i> for this purpose. 
        We can register an event handler for a simple path expression and our
        handler will be called whenever the path is complete.
        So to process each &lt;ROW&gt; individually we can do the following.
      </p>
      <pre>
// enable pruning mode to call me back as each ROW is complete
SAXReader reader = new SAXReader();
reader.setPruningMode( "/ROWSET/ROW", 
    new ElementHandler() {
        public void handle(Element row) {
            // process a ROW element
            Element rowSet = row.getParent();
            Document document = row.getDocument();
            ...
        }
    }
);

Document document = reader.read(url);

// The document will now be complete but all the ROW elements
// will have been pruned.
// We may want to do some final processing now
...
      </pre>
    </section>


    <section title="Does DOM4J support the Visitor Pattern?">
      <p>Yes. <b>DOM4J</b> supports the visitor pattern via the 
          <a href="apidocs/org/dom4j/Visitor.html">Visitor</a> interface.
      </p>
      <p>Here is an example.
      </p>
      <pre>
protected void foo(Document doc) {
  
    // lets use the Visitor Pattern to 
    // navigate the document for entities

    Visitor visitor = new VisitorSupport() {
        public void visit(Entity entity) {
            System.out.println( 
                "Entity name: " + entity.getName() 
                + " text: " + entity.getText() 
            );
        }
    };

    doc.accept( visitor );
}
      </pre>
    </section>


    <section title="Can I sort the List returned by Node.selectNodes()?">
      <p>Yes. The selectNodes() is a really useful feature to allow nodes to be
        selected from any object in the DOM4J object model via an XPath expression. 
        The List that is returned can be sorted by
        specifying another XPath expression to use as the sorting comparator.
      </p>
      <p>
      For example the following code parses an XML play and finds all the
      SPEAKER elements sorted in name order. 
      </p>
      <pre>
SAXReader reader = new SAXReader();
Document document = reader.read( new File( "xml/much_ado.xml" ) );
List speakers = document.selectNodes( "//SPEAKER", "." );
      </pre>
      <p>
      In the above example the name of the SPEAKER is
      defined by the XPath expression "." as the name is stored in the text 
      of the SPEAKER element. 
      If the name was defined by an attribute called "name" then 
      the XPath expression "@name" should be used for sorting.
      </p>
      <p>
      You may wish to remove duplicates while sorting such that (for example)
      the distinct list of SPEAKER elements is returned, sorted by name.
      To do this add an extra parameter to the selectNodes() method call.
      </p>
      <pre>
List distinctSpeakers = document.selectNodes( "//SPEAKER", ".", true );
      </pre>
    </section>


    <section title="What features are optional in DOM4J?">
      <p>In <b>DOM4J</b> being able to navigate up a tree towards the parent
        and to be able to change a tree are optional features. 
        These features are optional so that an implementation
        can create memory efficient read only document models which
        conserve memory by sharing imutable objects (such as interning 
        Atttributes).
      </p>
        
      <p>There are some helper methods to determine if optional features are 
        implemented. 
        Here is some example code demonstrating their use.
      </p>
      <pre>
protected void foo(Node node) {
  
    // can we do upward navigation?
    if ( ! node.supportsParent() ) {
        throw new UnsupportedOperationException(
          "Cannot navigate upwards to parent"
        );
    }
    Element parent = node.getParent();

    System.out.println( "Node: " + node 
        + " has parent: " + parent 
    );

    if ( parent != null ) {

        // can I modify the parent?
        if ( parent.isReadOnly() ) {
            throw new UnsupportedOperationException(
              "Cannot modify parent as it is read only"
            );
        }

        parent.setAttributeValue( "bar", "modified" );
    }
}
      </pre>
    </section>

  </body>
</document>









